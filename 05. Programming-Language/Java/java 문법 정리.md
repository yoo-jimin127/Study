### java 문법 정리

#### 인터페이스
- class 키워드 대신 interface 키워드를 사용해 정의
- 내부에는 추상 메소드 선언
- 클래스에서 인터페이스를 받아 완성할 때 implements 키워드 사용
- java는 다중 상속 지원 X, 인터페이스 사용하여 다중 상속과 비슷하게 코드 작성 가능

******

#### 익명 내부 클래스
- 이름이 없는 내부 클래스
- 한 번만 사용하고 버려지는 클래스에 사용

******

#### 제네릭스
- 데이터 형식의 안전성을 보장하는 데 사용
- string, integer, double, 사용자 정의 클래스형에 사용

```java
    ArrayList strList = new ArrayList();
    strList.add("first");
    strList.add("second");
    strList.add(3);
```

```java
    ArrayList<String> strList = new ArrayList<String>();
    strList.add("first");
    strList.add("second");
    strList.add(3);
```

### 상속과 컴포지션
#### 상속
- 상속 : **IS-A 관계**로 정의될 수 있으며, 부모 클래스를 확장하는 개념
- 상속을 받은 자식 클래스는 부모 클래스의 변수와 메소드에 접근 가능, 메소드 재정의 가능
    - 생성자, static block은 상속 X
    - private 선언자는 접근 불가능, final 선언자는 재정의 불가능

1. 코드의 재사용을 통해 중복을 줄임
2. 확장성 증가
3. 클래스 간 계층적 관계를 구성하여 다형성 구현 가능

[단점]
- 캡슐화를 깨트릴 수 있음
    - 상위 클래스의 변수 및 메소드가 하위 클래스에 노출됨
    - 하위 클래스와 상위 클래스의 결합성이 강해질 수 있음
    - 상위 클래스의 내부 구현이 달라질 경우 수정 사항이 없는 하위 클래스에서 동작이 정상적으로 이루어지지 않을 수 있음

#### 컴포지션
- 컴포지션 : **HAS-A 관계**로 정의될 수 있으며, 기존 클래스가 새로운 클래스의 구성요소가 되는 것
- 기존에 존재하는 객체를 멤버변수로 이용함
- 기존의 클래스를 확장하는 대신 새로운 클래스를 만듦
- private 필드로 기존 클래스의 인스턴스를 참조하게 하는 방법 사용

[보완]
- 상속의 캡슐화를 깨지게 하는 문제 및 상위 클래스와 하위 클래스 간의 결합도와 의존도를 낮출 수 있음