## 1장. 깨끗한 코드

- 이 책을 통해 연습해 볼 것    
1. 코드에 대해 많은 사실을 배울 것    
2. 좋은 코드와 나쁜 코드를 구분하는 능력을 쌓을 것    
3. 나쁜 코드를 좋은 코드로 바꾸는 실력을 쌓을 것    

### ✅ 코드가 존재하리라
- 코드의 종말이 코 앞에 닥쳤다고 주장하는 사람이 있으나, 앞으로 코드가 사라질 가망은 없음    
    → 코드는 요구사항을 상세히 표현하는 수단(언어)    

### ✅ 나쁜 코드
- 나쁜 코드를 짜는 이유
    - 급함, 서두름
    - 코드를 다듬는 시간을 보냈다가 욕 먹을까봐
    - 지겨움
    - 밀린 업무

- 당장 돌아가는 프로그램에 안도감을 느끼고 추후에 정리하고자 하는 자세     
    → 나중은 오지 않음    

### ✅ 나쁜 코드로 치르는 대가
- 나쁜 코드가 쌓임 → 팀 생산성의 하락
- 나쁜 코드 → 개발 속도의 하락 → 인력 추가 → 적응에 많은 시간 필요 & 설계 의도에 맞는 변경 이해의 어려움 → 나쁜 코드 양산
- 악순환이 반복되다가 결국 재설계를 계획
    - 오랜 기간이 필요한 작업

### ✅ 태도
- 나쁜 코드의 책임은 프로그래머에게 있음
- 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못함

### ✅ 원초적 난제
- **코드를 최대한 깨끗하게 유지하는 습관** → 개발 속도를 높이는 방법

### ✅ 깨끗한 코드라는 예술
- 코드 감각을 통해 좋은 코드와 나쁜 코드를 구분
- 좋은 코드로 개선

### ✅ 깨끗한 코드란?
- 비야네 스트롭스트룹 (C++ 창시자)
  - 우아하고 효율적인 코드
    - 우아한 → 보기에 즐거운
    - 효율적인 → 속도 뿐만 아니라 CPU 자원을 낭비하지 않는
  - 간단한 논리로 버그가 숨어들지 못하게 만듦
  - 의존성을 최대한 줄여 유지보수가 쉽도록 만듦
  - 깨끗한 코드는 한 가지에 '집중'하는 것

- 그래디 부치
  - 단순하고 직접적 → '가독성'
  - 설계자의 의도를 드러내는 코드
  - 명쾌한 추상화와 단순한 제어문으로 가득함
    - 명쾌한 → 코드는 추측이 아니라 사실에 기반해야 하며, 반드시 필요한 내용만 담아야 함

- 데이브 토마스 (OTI 창립자)
  - 작성자가 아닌 사람도 읽기 쉽고 고치기 쉬운 코드
  - 테스트 케이스가 존재하는 코드
    - 단위 테스트 케이스, 인수 테스트 케이스
  - 의존성 최소, 각 의존성을 명확히 정의할 것
  - 코드는 문학적으로 표현해야 한다. → 인간이 읽기 좋은 코드

- 마이클 페더스
  - 주의 깊게 작성한 코드
  - 고칠 곳이 없는 코드

- 론 제프리스
  - 중복 피하기
  - 한 기능만 수행하기
  - 표현력 높이기
  - 간단한 추상화 고려하기

- 워드 커닝햄 (wiki 창시자)
  - 짐작했던 기능을 각 루틴이 그대로 수행하는 코드

### ✅ 우리는 저자다
- 우리는 저자 → 저자에게는 독자가 있음 → 저자 : 독자와 잘 소통할 책임이 있음
- 코드를 짤 때 본인이 **저자**라는 사실을 잊지 말 것
    - 우리의 노력을 보고 판단을 내릴 **독자**가 있다는 사실을 기억할 것

- 서둘러 끝내고 쉽게 짜려면 **읽기 쉽게** 코드를 작성할 것
    - 주변 코드를 읽지 않을 경우 새 코드를 짜지 못 함
    - 주변 코드가 읽기 어려울 경우 새 코드를 짜기 어려움

### ✅ 보이스카우트 규칙
    - 잘 짠 코드 ➕ 시간이 지나도 깨끗하게 유지되는 코드
    - 변수 이름 개선
    - 긴 함수의 기능 분할
    - 중복 제거
    - 복잡한 if문 제거
    - ...   
    - [ ] 시간이 지날수록 코드가 좋아지는 프로젝트

### ✅ 프리퀄과 원칙
    - Agile Software Development: `Principles`, `Patterns`, and `Practices` - PPP
    - 설계 원칙
        - SRP (Single Responsibility Principle)
        - OCP (Open Closed Principle)
        - DIP (Dependency Inversion Principle)
