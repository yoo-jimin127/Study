# 면접을 위한 CS 전공지식 노트

## 1. 디자인 패턴과 프로그래밍 패러다임

- 라이브러리 : 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것
    
    → 폴더명, 파일명 등에 대한 규칙 X, 프레임워크 대비 자유로움
    
- 프레임워크 : 공통으로 사용될 수 있는 특정한 기능들 모듈화
    
    → 폴더명, 파일명 등에 대한 규칙 O, 라이브러리 대비 자유로움
    

- 디자인 패턴 : 프로그램 설계 시 발생한 문제를 객체 간 상호 관계 등을 이용해 해결할 수 있도록 규약 형태로 만들어놓은 것

### 1. 싱글톤 패턴

**하나의 클래스에 오직 하나의 인스턴스**만 가지는 패턴

→ 데이터베이스 연결 모듈에 많이 사용

- 하나의 인스턴스를 만들어놓고, 해당 인스턴스를 다른 모듈들이 공유하며 사용 good
    
    → 인스턴스 생성 시 드는 비용 절감 (장점)
    
    → 의존성 높아짐 (단점)
    

- JS : 리터럴 `{}`, `new Object`로 객체 생성 시 → 다른 어떤 객체와도 같지 않음
    
    → 자체만으로 싱글톤 구현 O 
    

[](https://github.com/wnghdcjfe/csnote/blob/main/ch1/3.js)

- **싱글톤 패턴 단점**
    - **TDD(테스트 주도 개발)**에 걸림돌
        
        → 단위 테스트 : 테스트가 서로 독립적이어야 함 
        
        → 테스트를 어떤 순서로든 실행할 수 있어야 함
        
    
    : 싱글톤 패턴 - 미리 생성된 하나의 인스턴스 기반으로 구현 → 각 테스트별 독립적 인스턴스 생성 hard
    
- **의존성 주입**
    - **모듈 간 결합**을 강하게 만들 수 있음 (단점)
        
        → **의존성 주입**(DI, Dependency Injection) 통해 모듈 간 결합 느슨하게 만들어 해결 가능
        
        - 의존성(= 종속성) : A가 B에 의존성 ? B의 변경사항에 대해 A도 변해야 함을 의미
    - 메인 모듈이 직접 하위 모듈에 의존성 주는 것 X → 의존성 주읩자가 가로채 간접적으로 의존성 주의
        
        → 메인 모듈이 하위 모듈에 대한 의존성 ⬇️ == 디커플링
        
    - 모듈 **쉽게 교체할 수 있는 구조** 됨 (장점)
    - 마이그레이션, 테스팅 용이 (장점)
    - 구현 시 추상화 레이어, 이를 기반으로 구현체 넣어줌
        
        → 애플리케이션 의존성 방향 일관됨, 추론 쉬워짐, 모듈 간 관계 명확해짐
        
    - 의존성 주입 단점 : 모듈이 더 분리, 클래스 수 늘어 복잡성 증가될 수 있음, 약간의 런타임 패널티
    - 의존성 주입 원칙
        - “상위 모듈은 하위 모듈에서 어떤 것도 가져오지 않아야 함”
        - “둘 다 추상화에 의존해야 함”
        - “추상화는 세부 사항에 의존하지 않아야 함”

### 2. 팩토리 패턴

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴

상속 관계에 있는 두 클래스에서 

- 상위 클래스 - 중요한 뼈대 결정
- 하위 클래스 - 객체 생성에 관한 구체적 내용 결정
    
    → 분리되므로 느슨한 결합, 상위 클래스 : 인스턴스 생성 방식 알 필요 X → 유연성 ⬆️
    
    → 객체 생성 로직이 따로 떼어져 있으므로 코드 리팩터링 시 한 곳만 수정 → 유지보수성 ⬆️
    

[](https://github.com/wnghdcjfe/csnote/blob/main/ch1/5.js)

- `enum` : 상수의 집합 정의에 사용되는 타입

### 3. 전략 패턴 (= 정책 패턴)

객체의 행위를 바꾸고 싶은 경우 ~~직접 수정~~, 전략이라 부르는 **캡슐화한 알고리즘**을 컨텍스트 내에서 바꿔 상호교체되도록 하는 패턴

- passport : Node.js에서 인증 모듈 구현 시 쓰는 미들웨어 라이브러리 → 전략 기반 인증

[](https://github.com/wnghdcjfe/csnote/blob/main/ch1/8.js)

### 4. 옵저버 패턴

주체가 **어떤 객체의 상태 변화를 관찰**하다가 **상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화** 주는 패턴

- 주체 : 객체의 상태 변화를 보고 있는 관찰자
- 옵저버 : 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로, 추가 변화 사항이 생기는 객체

주로 이벤트 기반 시스템에 사용, MVC(Model-View-Controller) 패턴에도 사용

- **상속** : 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용, 자식 클래스에서 추가 및 확장 O
    
    → 재사용성, 중복성 최소화
    
- **구현** : 부모 인터페이스를 자식 클래스에서 재정의해 구현
    
    → 반드시 부모 클래스의 메서드를 재정의해 구현(상속과의 차이)
    

→ 상속 : 일반 클래스, abstract 클래스 기반 구현

→ 구현 : 인터페이스 기반 구현

- **JS에서의 옵저버 패턴**
    - 프록시 객체 : 어떠한 대상의 기본적 동작의 작업을 가로챌 수 있는 객체
        - 프록시 객체가 가지는 두개의 매개변수
            - `target` : 프록시할 대상
            - `handler` : target 동작을 가로채고 어떤 동작을 할 것인지 설정된 함수
    
    [](https://github.com/wnghdcjfe/csnote/blob/main/ch1/10.js)
    
    → vue.js 3.0 : ref, reactive로 정의 시 해당 값이 변경되었을 때 자동으로 DOM에 있는 값 변경됨
    
    → vue.js 3.0의 옵저버 패턴
    
    ### 5. 프록시 패턴과 프록시 서버
    
    4의 프록시 객체 : 프록시 패턴이 녹아든 객체
    
    → 프록시 패턴 : 대상 객체에 접근하기 전 **그 접근에 대한 흐름을 가로채** 대상 객체 앞단의 인터페이스 역할을 하는 디자인패턴
    
    - 객체의 속성, 변환 등을 보완
    - 보안, 데이터 검증, 캐싱, 로깅에 사용
    
    - 프록시 서버 : 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템
        
        → 캐시 : 캐시 안에 정보 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 원격 서버 요청 X, 캐시 내부 데이터 활용
        
    
    ex) nginx : 비동기 이벤트 기반의 구조, 다수의 연결 효과적으로 처리 가능한 웹서버
    
    Node.js 서버 앞단 프록시 서버로 사용
    
    ex) cloudflare : 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어, HTTPS 구축에 사용
    
    - **CORS(Cross-Origin Resource Sharing) & FE의 프록시 서버**
        - CORS : 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
        - 해결 법으로 FE에서 프록시 서버 만들기도 함
    
    ### 6. 이터레이터 패턴
    
    이터레이터를 사용해 컬렉션의 요소들에 접근하는 디자인 패턴
    
    → 이터레이터는 하나의 인터페이스로 순회 가능 (여러가지 자료형의 구조와 상관 X)
    
    [](https://github.com/wnghdcjfe/csnote/blob/main/ch1/11.js)
    
    - 이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
    - 이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체
    
    ### 7. 노출모듈 패턴
    
    즉시 실행 함수를 통해 `private`, `public` 같은 접근 제어자 만드는 패턴
    
    → JS에서 노출모듈 패턴을 통해 `private`, `public` 접근 제어자 구현
    
    [](https://github.com/wnghdcjfe/csnote/blob/main/ch1/12.js)
